//
//  ViewController.swift
//  Camera
//
//  Created by Charles Catta on 2018-10-05.
//  Copyright Â© 2018 Charles Catta. All rights reserved.
//

import UIKit
import Photos
import AVFoundation
import MediaPlayer

class ViewController: UIViewController {
    
    let captureSession = AVCaptureSession()
    @IBOutlet fileprivate var captureButton: UIButton!
    ///Displays a preview of the video output generated by the device's cameras.
    @IBOutlet var photoCapturedLabel: UILabel!
    @IBOutlet var AFFocusLabel: UILabel!
    @IBOutlet var AELabel: UILabel!
    @IBOutlet var previewView: PreviewView!
    @IBOutlet fileprivate var capturePreviewView: UIView!
    override var prefersStatusBarHidden: Bool { return true }
    let captureProcessor = CaptureProcessor()
    var captureOutput: AVCapturePhotoOutput?
    @objc var captureDevice: AVCaptureDevice?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = .black
        captureSession.beginConfiguration()
        
        self.captureDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back)
        guard let photoDeviceInput = try? AVCaptureDeviceInput(device: captureDevice!), captureSession.canAddInput(photoDeviceInput) else { return }

        captureSession.addInput(photoDeviceInput)
        self.captureSession.sessionPreset = .photo
        self.previewView.videoPreviewLayer.session = self.captureSession
        
        self.captureOutput = AVCapturePhotoOutput()
        self.captureOutput?.isHighResolutionCaptureEnabled = true
        captureSession.addOutput(self.captureOutput!)
        
        self.captureSession.commitConfiguration()
        self.captureSession.startRunning()
        
        // Flashlight
        do {
            try captureDevice?.lockForConfiguration()
            captureDevice?.torchMode = .on
            captureDevice?.focusMode = .continuousAutoFocus
            captureDevice?.exposureMode = .continuousAutoExposure
            captureDevice?.unlockForConfiguration()
        } catch {
            let errorPopup = UIAlertController(title: "Error", message: "Error turning on the flash!", preferredStyle: .alert)
            self.present(errorPopup, animated: true, completion: nil)
        }
        // Add event listener for AF
        addObserver(self, forKeyPath: #keyPath(captureDevice.focusMode), options: [.old, .new], context: nil)
        
        addObserver(self, forKeyPath: #keyPath(captureDevice.exposureMode), options: [.old, .new], context: nil)
        
        // Update first time
        self.updateFocusModeState()
        self.updateExposureModeState()
        
        // detect soundshutter
        AVAudioSession.sharedInstance().addObserver(self, forKeyPath: "outputVolume", options: NSKeyValueObservingOptions.new, context: nil)
        do { try AVAudioSession.sharedInstance().setActive(true) }
        catch { print("\(error)") }
        NotificationCenter.default.addObserver(self, selector: #selector(onPhotoSaveError(_:)), name: .photoSaveError, object: nil)
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "outputVolume" {
            self.capturePhoto()
        } else if keyPath == #keyPath(captureDevice.focusMode) {
            self.updateFocusModeState()
        } else if keyPath == #keyPath(captureDevice.exposureMode) {
            self.updateExposureModeState()
        }
    }
    
    func updateFocusModeState() {
        guard let device = self.captureDevice else { return }
        switch device.focusMode {
        case .locked:
            self.AFFocusLabel.text = "FOCUS LOCKED"
            self.AFFocusLabel.textColor = .red
            
        case .autoFocus:
            self.AFFocusLabel.text = "FOCUSING..."
            self.AFFocusLabel.textColor = .green
            
        case .continuousAutoFocus:
            self.AFFocusLabel.text = "CONTINUOUSLY FOCUSING"
            self.AFFocusLabel.textColor = .yellow
        }
    }
    
    func updateExposureModeState() {
        guard let device = self.captureDevice else { return }
        switch device.exposureMode {
        case .locked:
            self.AELabel.text = "EXPOSURE LOCKED"
            self.AELabel.textColor = .red
        case .autoExpose:
            self.AELabel.text = "EXPOSING ..."
            self.AELabel.textColor = .green
        case .continuousAutoExposure:
            self.AELabel.text = "CONTINUOUSLY EXPOSING"
            self.AELabel.textColor = .yellow
        case .custom:
            self.AELabel.text = ""
        }
    }
    
    func capturePhoto() {
        let captureSettings = AVCapturePhotoSettings()
        self.captureOutput?.capturePhoto(with: captureSettings, delegate: captureProcessor)
        self.photoCapturedLabel.alpha = 1.0
        UIView.animate(withDuration: 1.5, animations: {
            self.photoCapturedLabel.alpha = 0.0
        })
    }
    
    @objc func onPhotoSaveError(_ notification: Notification) {
        if let data = notification.userInfo as? [Int: String] {
            let errorPopup = UIAlertController(title: "Error", message: "Unable to save picture: \(data[0] ?? "")", preferredStyle: .alert)
            self.present(errorPopup, animated: true, completion: nil)
        }
    }
    
    @IBAction func onFocusBtnTap(_ sender: UIButton) {
        do {
            try self.captureDevice?.lockForConfiguration()
            self.captureDevice?.focusMode = .autoFocus
            self.captureDevice?.unlockForConfiguration()
        } catch {
            let errorPopup = UIAlertController(title: "Error", message: "Unable to switch focus modes: \(error.localizedDescription)", preferredStyle: .alert)
            self.present(errorPopup, animated: true, completion: nil)
        }
    }

    @IBAction func onTorchBtnTap(_ sender: UIButton) {
        do {
            try self.captureDevice?.lockForConfiguration()
            if (self.captureDevice?.torchMode == .on) {
                self.captureDevice?.torchMode = .off
            } else {
                self.captureDevice?.torchMode = .on
            }
            self.captureDevice?.unlockForConfiguration()
        } catch {
            let errorPopup = UIAlertController(title: "Error", message: "Unable to switch torch mode: \(error.localizedDescription)", preferredStyle: .alert)
            self.present(errorPopup, animated: true, completion: nil)
        }
    }
    
    @IBAction func onExposeBtnTap(_ sender: UIButton) {
        do {
            try self.captureDevice?.lockForConfiguration()
            self.captureDevice?.exposureMode = .autoExpose
            self.captureDevice?.unlockForConfiguration()
        } catch {
            let errorPopup = UIAlertController(title: "Error", message: "Unable to switch exposure modes: \(error.localizedDescription)", preferredStyle: .alert)
            self.present(errorPopup, animated: true, completion: nil)
        }
    }
    
    @IBAction func CaptureBtnTouched(_ sender: UIButton) {
        self.capturePhoto()
    }
}


class PreviewView: UIView {
    override class var layerClass: AnyClass {
        return AVCaptureVideoPreviewLayer.self
    }
    
    /// Convenience wrapper to get layer as its statically known type.
    var videoPreviewLayer: AVCaptureVideoPreviewLayer {
        return layer as! AVCaptureVideoPreviewLayer
    }
}


class CaptureProcessor: NSObject, AVCapturePhotoCaptureDelegate {
    func handleError(_ err: Error) {
        let error = err.localizedDescription
        NotificationCenter.default.post(name: .photoSaveError, object: self, userInfo: [0: error])
    }
    
    func handleError(_ err: String) {
        NotificationCenter.default.post(name: .photoSaveError, object: self, userInfo: [0: err])
    }
    
    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
        if error != nil {
            
        }
        
        PHPhotoLibrary.requestAuthorization { status in
            guard status == .authorized else { return }
            
            PHPhotoLibrary.shared().performChanges({
                // Add the captured photo's file data as the main resource for the Photos asset.
                guard let data = photo.fileDataRepresentation() else {
                    self.handleError("Data sent from camera was null!")
                    return
                }
                let creationRequest = PHAssetCreationRequest.forAsset()
                creationRequest.addResource(with: .photo, data: data, options: nil)
            }, completionHandler: nil)
        }
    }
}


extension Notification.Name {
    static let photoSaveError = Notification.Name("photoSaveError")
}
